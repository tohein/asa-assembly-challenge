import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import static java.lang.Math.min;

/**
 * Various utility functions for reading, writing and processing
 * DNAString reads.
 *
 * @author tohei
 */
public final class DNAStringUtils {

    private DNAStringUtils() {
        throw new AssertionError();
    }

    /**
     * Computes for every k-mer (and its reverse complement, if includeRC = true) the
     * number of reads which contain them.
     * <p>
     *
     * @param reads array of reads.
     * @param k     k-mer length.
     * @param includeRC count reverse complement.
     * @return LinkedHashSet mapping k-mers to counts.
     */
    public static LinkedHashMap<DNAString, Integer> kmerCounts(DNAString[] reads, int k, boolean includeRC) {
        LinkedHashMap<DNAString, Integer> kmerCounts = new LinkedHashMap<DNAString, Integer>(reads.length);
        for (DNAString s : reads) {
            // updated contains all k-mers found in read s
            LinkedHashSet<DNAString> updated = new LinkedHashSet<DNAString>();
            for (int i = 0; i < s.length() - k + 1; i++) {
                DNAString kmer = s.subSequence(i, i + k);
                DNAString kmerRC = kmer.reverseComplement();
                if (!updated.contains(kmer)) {
                    int count = 1;
                    if (kmerCounts.containsKey(kmer)) {
                        count += kmerCounts.get(kmer);
                    }
                    kmerCounts.put(kmer, count);
                    if (includeRC) kmerCounts.put(kmerRC, count);
                }
                updated.add(kmer);
                if (includeRC) updated.add(kmerRC);
            }
        }
        return kmerCounts;
    }

    /**
     * Computes for every k-mer and its reverse complement the
     * number of reads which contain them.
     * <p>
     *
     * @param reads array of reads.
     * @param k     k-mer length.
     * @return LinkedHashSet mapping k-mers to counts.
     */
    public static LinkedHashMap<DNAString, Integer> kmerCounts(DNAString[] reads, int k) {
        return kmerCounts(reads, k, true);
    }

    /**
     * Reads in a FASTA file and returns reads in a string array.
     *
     * @param fileName String containing full path to FASTA file.
     * @return DNAString array containing reads.
     * @throws FileNotFoundException
     * @throws IOException
     */
    public static DNAString[] readFasta(String fileName) throws FileNotFoundException, IOException {
        String line;
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        ArrayList<DNAString> sequences = new ArrayList<DNAString>();
        String seq = "";
        while ((line = in.readLine()) != null) {
            if (line.startsWith(">")) {
                if (seq.length() > 0) {
                    sequences.add(new DNAString(seq));
                }
                seq = "";
            } else {
                seq = seq + line;
            }
        }
        if (seq.length() > 0) {
            sequences.add(new DNAString(seq));
        }
        in.close();
        return sequences.toArray(new DNAString[sequences.size()]);
    }

    /**
     * Writes DNAString array to FASTA file.
     *
     * @param fileName path to output file.
     * @param reads    DNAString array containing reads.
     * @throws FileNotFoundException
     * @throws IOException
     */
    public static void writeFasta(String fileName, DNAString[] reads) throws IOException {
        final int MAX_LENGTH = 80;

        PrintWriter writer = new PrintWriter(fileName, "UTF-8");
        for (int i = 0; i < reads.length; i++) {
            writer.println(">CONTIG_" + i);
            DNAString seq = reads[i];
            // each line of a sequence should have fewer than 80 characters
            for (int j = 0; j < seq.length(); j += MAX_LENGTH) {
                writer.println(seq.subSequence(j, min(seq.length(), j + MAX_LENGTH)).toString());
            }
        }
        writer.close();
    }

    /**
     * Saves k-mer counts map to tab separated file.
     *
     * @param fileName path to output file.
     * @param counts   Map as generated by kmerCounts.
     * @throws IOException
     */
    public static void saveKmerCounts(String fileName, LinkedHashMap<DNAString, Integer> counts) throws IOException {
        PrintWriter writer = new PrintWriter(fileName, "UTF-8");
        for (Map.Entry<DNAString, Integer> entry : counts.entrySet()) {
            writer.println(entry.getKey().toString() + "\t" + entry.getValue());
        }
        writer.close();
    }

    /**
     * Compute the Levenshtein distance between two DNAStrings.
     * @param s1 first input DNAString.
     * @param s2 second input DNAString.
     * @return Levenstein distance between s1 and s2.
     */
    public static int LevDistance(DNAString s1, DNAString s2) {
        int len1 = s1.length();
        int len2 = s2.length();

        int[][] D = new int[len1 + 1][len2 + 1];

        for (int i = 0; i < len1 + 1; i++) {
            D[i][0] = i;
        }
        for (int j = 0; j < len2 + 1; j++) {
            D[0][j] = j;
        }

        for (int i = 0; i < len1; i++) {
            byte b1 = s1.byteAt(i);
            for (int j = 0; j < len2; j++) {
                byte b2 = s2.byteAt(j);
                if (b1 == b2) {
                    D[i + 1][j + 1] = D[i][j];
                } else {
                    // replacement and insertion
                    D[i + 1][j + 1] = min(D[i][j] + 1, D[i][j + 1] + 1);
                    // deletion
                    D[i + 1][j + 1] = min(D[i + 1][j + 1], D[i + 1][j] + 1);
                }
            }
        }
        return D[len1][len2];
    }
}
